---
## Front matter
title: "Отчет по лабораторной работе номер 9"
subtitle: "Понятие подпрограммы. Отладчик GDB"
author: "Виктор Ващаев Андреевич"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы
Целью данной лабораторной работы является изучение основных операций арифметики на языке ассемблера и применение подпрограмм для выполнения вычислений. Задача состоит в реализации программы для вычисления выражения , анализа кода с помощью отладчика GDB, поиска и исправления ошибок в программе.
# Задание

Здесь приводится описание задания в соответствии с рекомендациями
методического пособия и выданным вариантом.

# Теоретическое введение
Понятие об отладке
Отладка — это процесс поиска и исправления ошибок в программе. В общем случае его
можно разделить на четыре этапа:
• обнаружение ошибки;
• поиск её местонахождения;
• определение причины ошибки;
• исправление ошибки.
Можно выделить следующие типы ошибок:
• синтаксические ошибки — обнаруживаются во время трансляции исходного кода и
вызваны нарушением ожидаемой формы или структуры языка;
• семантические ошибки — являются логическими и приводят к тому, что программа
запускается, отрабатывает, но не даёт желаемого результата;
• ошибки в процессе выполнения — не обнаруживаются при трансляции и вызывают пре-
рывание выполнения программы (например, это ошибки, связанные с переполнением
или делением на ноль).
Второй этап — поиск местонахождения ошибки. Некоторые ошибки обнаружить доволь-
но трудно. Лучший способ найти место в программе, где находится ошибка, это разбить
программу на части и произвести их отладку отдельно друг от друга.
Третий этап — выяснение причины ошибки. После определения местонахождения ошибки
обычно проще определить причину неправильной работы программы.
Последний этап — исправление ошибки. После этого при повторном запуске программы,
может обнаружиться следующая ошибка, и процесс отладки начнётся заново.

# Выполнение лабораторной работы


Создаём каталог для выполнения лабораторной работы № 9, переходим в него и создаём файл lab09-1.asm.


![1 рисунок](/home/victor/Pictures/Снимки экрана/1.png){#fig:001 width=70%}




Вводим в файл lab09-1.asm текст программы из листинга 9.1. Создаем исполняемый
файл и проверяем его работу.


![2 рисунок](/home/victor/Pictures/Снимки экрана/2 создаем исполняемый файл и проверяем работу.png){#fig:001 width=70%}




Изменяем текст программы: добавляем подпрограмму _subcalcul внутрь подпрограммы _calcul для вычисления выражения . В основной программе вводим  с клавиатуры, передаём его в подпрограмму _calcul. Подпрограмма _calcul передаёт  в _subcalcul, где вычисляется . Результат  возвращается в _calcul, где вычисляется . Итоговый результат возвращается в основную программу для вывода на экран.


![3 рисунок](/home/victor/Pictures/Снимки экрана/3 подпрограмма в подпрограмме.png){#fig:001 width=70%}




Создаём файл lab09-2.asm с текстом программы из Листинга 9.2 (программа печати сообщения “Hello, world!”). Затем получаем исполняемый файл, добавляя отладочную информацию при трансляции с помощью соответствующего ключа. Загружаем исполняемый файл в отладчик GDB и проверяем работу программы, запуская её в GDB с помощью команды run (сокращённо r).


![4 рисунок](/home/victor/Pictures/Снимки экрана/4 все по инструкции.png){#fig:001 width=70%}




Для более детального анализа программы устанавливаем брейкпоинт на метку _start, с которой начинается выполнение любой ассемблерной программы. Затем запускаем программу в отладчике GDB.


![brakepoint](/home/victor/Pictures/Снимки экрана/6.png){#fig:001 width=70%}




1 Просматриваем дисассемблированный код программы:
С помощью команды disassemble _start выводим машинные команды, начиная с метки _start.
 2 Переключаемся на Intel-синтаксис:
Выполняем команду set disassembly-flavor intel для изменения отображения синтаксиса на Intel.
Повторно вводим команду disassemble _start для просмотра команд в новом синтаксисе.
 3 Различия синтаксиса в режимах ATT и Intel:
 • ATT (по умолчанию):
 • Использует префикс % для регистров (например, %eax).
 • Операнды: источник указывается первым, а назначение вторым (например, movl %eax, %ebx).
 • Intel:
 • Без префикса для регистров (например, eax).
 • Операнды: сначала указывается назначение, затем источник (например, mov ebx, eax).
 4.Включаем режим псевдографики:
 • Команда layout asm активирует окно с ассемблерными командами.
 • Команда layout regs добавляет отображение текущих значений регистров.

В результате:

 • Верхняя часть окна показывает названия регистров и их текущие значения.
 • Средняя часть отображает результат дисассемблирования программы.
 • Нижняя часть остаётся доступной для ввода команд в GDB.
 
 
 ![6](/home/victor/Pictures/Снимки экрана/7.png){#fig:001 width=70%}
 
 
![7](/home/victor/Pictures/Снимки экрана/8.png}{#fig:001 width=70%}




1 Регистры:
 • ATT: используются префиксы % (например, %eax).
 • Intel: префиксы отсутствуют (например, eax).
 2 Порядок операндов:
 • ATT: источник → назначение (например, movl %eax, %ebx).
 • Intel: назначение → источник (например, mov ebx, eax).
 3 Суффиксы команд:
 • ATT: указываются размеры (например, movl для 32-битных).
 • Intel: размеры операндов определяются автоматически.



[Изображение 8:](/home/victor/Pictures/Снимки экрана/9.png)




Проверяем наличие установленной точки останова на метке _start с помощью команды info breakpoints или её сокращённого варианта i b.


[Изображение 9:](/home/victor/Pictures/Снимки экрана/10.png)




Устанавливаем ещё одну точку останова по адресу инструкции. Адрес инструкции определяем в средней части экрана в левом столбце напротив предпоследней инструкции (mov ebx,0x0). Устанавливаем точку останова с помощью команды break *<адрес>. Проверяем информацию обо всех установленных точках останова командой i b.


[Изображение 10:](/home/victor/Pictures/Снимки экрана/11.png)




Так же мы можем заметить что при выполнении команды следующие регистры меняются 


[Изображение 11:](/home/victor/Pictures/Снимки экрана/12 мы можем заметить что следущие регистры меняются:.png)




Значение переменной msg1 и 2по имени:


[Изображение 12:](/home/victor/Pictures/Снимки экрана/13..png)




Измените первый символ переменной msg1: 


[Изображение](/home/victor/Pictures/Снимки экрана/1.png)




Меняем значение регистра:
p/s трактует значение как указатель на строку и выводит содержимое памяти в виде строки.



[Изображение](/home/victor/Pictures/Снимки экрана/Меняем значение регистра.png)




Теперь выполняем последние шаги: 


[Изображение](/home/victor/Pictures/Снимки экрана/Снимок экрана от 2024-12-07 10-02-02.png)


[Изображение](/home/victor/Pictures/Снимки экрана/Снимок экрана от 2024-12-07 10-04-23.png)




Самостоятельная работа: 
Ошибка в программе возникает из-за некорректного использования регистра ebx в процессе вычислений. Рассмотрим проблему более подробно:

Проблема

 1 После выполнения команды mov ecx,4 происходит умножение через команду mul ecx. Однако команда mul в 32-битной архитектуре выполняет умножение регистра eax на указанный операнд, а результат записывается в eax. При этом ebx не участвует в умножении.
 2 После выполнения команды mul ecx, результат оказывается в eax, но дальше в программе используется ebx, значение которого осталось без изменений.

Решение

Необходимо корректно использовать регистры и следить за их изменениями в процессе вычислений. Исправленный код был прикреплен.

# Выводы
1.В процессе выполнения работы было выявлено, что неправильное использование регистров для промежуточных вычислений может приводить к некорректным результатам. Это демонстрирует важность понимания работы инструкций процессора и управления регистрами.
 2 Исправленная программа успешно выполняет вычисление выражения , результат совпадает с ожидаемым значением .
 3.Отладка с использованием GDB показала изменения значений регистров на каждом этапе вычислений, что позволило обнаружить ошибку и корректно переработать алгоритм.
 4.Работа подчеркнула значимость организации кода в ассемблере, в частности, правильного управления регистрами, использования комментариев и структурирования программы для достижения правильных результатов.
 5.Опыт работы с ассемблером и отладчиком GDB улучшил навыки анализа низкоуровневого кода и понимание работы процессора на уровне инструкций.

# Список литературы{.unnumbered}

